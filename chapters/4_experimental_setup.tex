\section{Experimental Setup}

This section contains the hardware setup used to communicate with the low cost IMU sensors and the platform that the Kalman filter is implemented on. There were two Inertial
Navigation Systems (INS) used to compare the results of the implemented Kalman filter to,
the MIDGII and the UmarimLite. The MIDGII is an expensive INS known as the golden
standard for AHRS and the UmarimLite is a commercially available low-cost AHRS that
uses the open source Paparazzi autopilot software. The experimental setup was chosen such
that the algorithm could be designed and tested without any of the low-cost considerations, this makes it possible to develop the algorithm with no constraints and then optimize the
algorithm for low-cost systems.

\subsection{Hardware}

As our projected solution involved a low-cost navigation system, the hardware selection criteria were primarily founded on availability and cost. The cost reduction normally concedes in accurateness and reliability, although with the recent surge of inexpensive, widely accessible, and precise microelectromechanical systems (MEMS), that is no longer the case. Still, we aim to employ commercially available tools at the lowest possible cost without compromising the design of a robust and accurate inertial navigation system. A LoPy microcontroller was selected as the navigational computing device of the inertial system, meeting the envisioned requirements for low power with flexible and diverse computational capabilities. The LoPy development board interfaces with the external physical inertial sensor through connection pins (figure \ref{fig:hardware}.a) and communicates remotely by LoRa protocol. A PySense expansion board connects with the LoPy module providing a programable interface for the microcontroller. The inertial navigation system encompasses a small MPU-9250 (figure \ref{fig:hardware}.b).

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/INS.jpg}
        \caption{INS Hardware}
        \label{fig:sub1}
    \end{subfigure}%
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/mpu9250.jpg}
        \caption{MPU-9250 Breakout}
        \label{fig:sub2}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
    \label{fig:hardware}
\end{figure}

MPU-9250 inertial measurement unit is one of the most widely available low cost commercial IMUs. It is also considered to have an exceptional quality price ratio. The MPU-9250 contains as well temperature and pressure sensors. This chip is extensively employed in wearable sensors for health, fitness, and sports, motion-based game controllers, and portable gaming. This IMU is operated to estimate motion by identifying the presence of acceleration vectors, rotational rates, and local magnetic field direction. It features an embedded 9-axis MEMS sensor from InvenSense. The MPU-9250 is a combined System-in-package (SIP) comprising an MPU-6050 (3-axis accelerometer and 3-axis gyroscope combination) and an AK8963 3-axis magnetometer.The MPU-6050 coordinate system operates within a traditional cartesian coordinate system with a counter-clockwise rotation as the positive rotation direction. The AK8963 shifts the x and y-axis directions, while reversing the direction of the z-axis. These conventions will be utilized during calibration for each of the three sensors.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/mpu_orientation.pdf}
    \caption{System overview - }
    \label{fig:mpu_orientation}
\end{figure}

\subsubsection{Accelerometer}

The triple-axis MEMS accelerometer in MPU-9250 includes a wide range of features:

\begin{itemize}
    \item Digital-output triple-axis accelerometer with a programmable full scale range  of $\pm 2g$, $\pm 4$, $\pm 8g$ and $\pm 16g$ and integrated 16-bit ADCs
    \item Accelerometer normal operating current: $450 \mu A$
    \item The text in the entries may be of any length
    \item Low power accelerometer mode current: $8.4 \mu A$ at $0.98Hz$, $19.8 \mu A$ at 31.$25Hz$
    \item Sleep mode current: $8 \mu A$
    \item User-programmable interrupts
    \item Wake-on-motion interrupt for low power operation of applications processor
    \item Self-test
\end{itemize}

\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                   & Min. & Typ.      & Max.   & Units             \\
            \hline
            Full-Scale range            &      & $\pm 16$  &        & $g$               \\
            Sensitivity Scale Factor    &      & 2,048     &        & $LSB/g$           \\
            Nonlinearity                &      & $\pm 0.1$ &        & $\%$              \\
            Rate Noise Spectral Density &      & 300       &        & $\mu g/\sqrt{Hz}$ \\
            Operating Current           &      & 3.2       &        & $mA$              \\
            Startup Time                &      & 20        &        & $ms$              \\
            Output Data Rate            & $4$  &           & $4000$ & $Hz$              \\
            \hline
        \end{tabular}
        \caption{Accelerometer Specifications. }
        \label{tab:accelerometer_specification}
    \end{center}
\end{table}

\subsubsection{Gyroscope}

The triple-axis MEMS gyroscope in the MPU-9250 includes a wide range of features:

\begin{itemize}
    \item Digital-output X-Axis, Y-Axis, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable fullscale range of $\pm 250$, $\pm 500$, $\pm 1000$, and $\pm 2000^{\circ}/s$ and integrated 16-bit ADCs
    \item Digitally-programmable low-pass filter
    \item Gyroscope operating current: $3.2mA$
    \item Sleep mode current: $8 \mu A$
    \item Factory calibrated sensitivity scale factor
    \item Self-test
\end{itemize}


\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                   & Min. & Typ.       & Max.   & Units                  \\
            \hline
            Full-Scale range            &      & $\pm 2000$ &        & $^{\circ}/s$           \\
            Sensitivity Scale Factor    &      & 131        &        & $LSB/(^{\circ}/s)$     \\
            Nonlinearity                &      & $\pm 0.5$  &        & $\%$                   \\
            Rate Noise Spectral Density &      & 300        &        & $^{\circ}/s/\sqrt{Hz}$ \\
            Operating Current           &      & 450        &        & $\mu A$                \\
            Startup Time                &      & 35         &        & $ms$                   \\
            Output Data Rate            & $4$  &            & $8000$ & $Hz$                   \\
            \hline
        \end{tabular}
        \caption{Gyroscope Specifications. }
        \label{tab:gyroscope_specification}
    \end{center}
\end{table}

\subsubsection{Magnetometer}

The triple-axis MEMS accelerometer in MPU-9250 includes a wide range of features:
\begin{itemize}
    \item 3-axis silicon monolithic Hall-effect magnetic sensor with magnetic concentrator
    \item Wide dynamic measurement range and high resolution with lower current consumption.
    \item Output data resolution of 14 bit ($0.6 \mu T/LSB$) or 16 bit ($15 \mu T/LSB$)
    \item Full scale measurement range is $\pm 4800 \mu T$
    \item Magnetometer normal operating current: $280\mu A$ at $8 Hz$ repetition rate
    \item Self-test function with internal magnetic source to confirm magnetic sensor operation on end products
\end{itemize}

\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                     & Min. & Typ.       & Max. & Units        \\
            \hline
            Full-Scale range              &      & $\pm 4800$ &      & $\mu T$      \\
            Sensitivity Scale Factor      &      & 0.6        &      & $\mu T/ LSB$ \\
            Operating Current             &      & 280        &      & $\mu A$      \\
            Initial Calibration Tolerance &      & $\pm 500$  &      & $LSB$        \\
            \hline
        \end{tabular}
        \caption{Magnetometer specification. }
        \label{tab:magnetometer_specification}
    \end{center}
\end{table}

\subsection{Software}
The microcontroller operates MicroPython, a barebones and efficient implementation of Python 3, which incorporates a small subset of the Python standard library. It is optimized to run on microcontrollers and in constrained environments. The inertial module's raw measurements are interpreted by the microcontroller through Inter-Integrated Circuit (I2C) MicroPython driver serial allowing to read the peripherals memory addresses synchronously. The readings of each sensor are later averaged and linearized to better detect and reduce the presence of outlier readings. A fusion algorithm takes as input the averaged data of the accelerometer, gyroscope, and magnetometer. It returns the estimated inertial angles (pitch, roll, and yaw) as well as the projected linear acceleration with a gravity compensation numerical method that utterly removes the effect of the gravity component. Numerically integrating the resultant linear acceleration yields velocity, and double integrating will deliver the body's accumulative position. Merging the AHRS with an accumulative position allows tracking a moving body in three dimensions over time.

\subsection{Calibration}

A correct calibration of such sensors is essential for the compensation of their systematic errors, bias, and scale factor. Each time prior to an experiment, the inertial sensor is calibrated while the system is stationary and stabilized to compensate for static error that might corrupt the measurements.

\subsubsection{Accelerometer Calibration}

Calibration of the accelerometer requires taking advantage of the acceleration due to gravity, which we can use in the positive and negative orientation of the IMU. Additionally, we can also position the IMU perpendicular to gravity in order to acquire a third calibration point. This results in three unique values that can be combined to formulate a linear fit between the three values and the values outputted by each axis of the accelerometer.

\lstset{language=Python}
\begin{lstlisting}[frame=single]  % Start your code-block

    count=256
    aox, aoy, aoz = (0.0, 0.0, 0.0)
    self._accelerometer_offset = (0.0, 0.0, 0.0)
    n = float(count)

    while count:
        utime.sleep_ms(delay)
        # taking samples for a period of time
        ax, ay, az = self.acceleration
        # sum every sample on each axis
        aox += ax
        aoy += ay
        aoz += az 
        count -= 1

    # average the samples taken
    self._accelerometer_offset = (aox / n, aoy / n, aoz / n)
    return self._accelerometer_offset
\end{lstlisting}

\begin{figure}[!h]
    \centering
    \resizebox{1\linewidth}{!}{\input{plots/accelerometer.pgf}}
    \caption{Sensor.}
    % \label{fig:sensoroutput} 
\end{figure}

\subsubsection{Gyroscope Calibration}

The simplest calibration of an IMU consists of calculating the offset for each axis of the gyroscope. The gyroscope is the easiest calibration due to the expected readings outputted under steady conditions. Each of the three axes of the gyro should read 0 degrees-per-second (dps, °/s) when the IMU is not moving. The offsets can be measured by first taking some readings while the IMU is not moving, then using those values as ‘offsets’ when reading the gyro values in the future. This is merely the simplest calibration method for the IMU and suffices for most casual uses of the gyroscope and IMU. There are a range of  higher-order gyroscope calibration routines, which can be found at the following links (with application descriptions):

\lstset{language=Python}

\begin{lstlisting}[frame=single]  % Start your code-block

    count=256
    gox, goy, goz = (0.0, 0.0, 0.0)
    self._gyro_offset = (0.0, 0.0, 0.0) 
    n = float(count)

    while count:
        # taking samples for a period of time
        utime.sleep_ms(delay)
        gx, gy, gz = self.gyro
        # sum every sample on each axis
        gox += gx
        goy += gy
        goz += gz
        count -= 1

    # average the samples taken
    self._gyro_offset = (gox / n, goy / n, goz / n)
    return self._gyro_offset, self._accelerometer_offset
\end{lstlisting}

\begin{figure}[!h]
    \centering
    \resizebox{1\linewidth}{!}{\input{plots/gyroscope.pgf}}
    \caption{Sensor.}
    % \label{fig:sensoroutput}
\end{figure}

\subsubsection{Magnetometer Calibration}

To calibrate the magnetometer, a series of measurements of the nearby magnetic field are taken while holding the sensor in an eight-figure pattern through every orientation possible. Ideally the measurements should portray a perfect sphere centered at the origin and where the radius of the sphere is the magnetic field's strength. Plotting the magnetometer's raw measurements (as seen in figure \ref{plt:raw_magnetometer} and figure \ref{plt:raw_magnetometer3D}), it is visible that these do not form a perfect sphere, nor are they centered at the origin. These are referred to as hard iron and soft iron errors or biases, respectively. If no magnetic anomaly algorithm is applied to perceive and avoid it, such distortions in the magnetic field can be interpreted as changes in orientation.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/magnetometer2D.pgf}}
        \caption{INS Hardware}
        \label{plt:raw_magnetometer}
    \end{subfigure}

    \begin{subfigure}{0.7\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/magnetometer3D.pgf}}
        \caption{MPU-9250 Breakout}
        \label{plt:raw_magnetometer3D}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
\end{figure}

Hard iron biases are commonly the largest and the simplest errors to rectify. With the magnetic field measurements, it is straightforward to compensate for hard iron biases by keeping track of the minimum and maximum field measured in $\widetilde{m}_x$, $\widetilde{m}_y$ and $\widetilde{m}_z$. Once the minimum and maximum field measured in $\widetilde{m}_x$, $\widetilde{m}_y$ and $\widetilde{m}_z$ are known, the average can be subtracted from the following data which results in the re-centering of the response surface on the origin. The following script illustrates how a hard iron correction could be implemented:

\lstset{language=Python}
\begin{lstlisting}[frame=single]  % Start your code-block

    # Hard iron correction

    # get average x mag bias in counts
    offset_x = (maxx + minx) / 2
    # get average y mag bias in counts
    offset_y = (maxy + miny) / 2
    # get average z mag bias in counts
    offset_z = (maxz + minz) / 2

    self._offset = (offset_x, offset_y, offset_z)
    return self._offset
\end{lstlisting}

It is possible now to filter any soft iron biases by taking the minimum and maximum field measured already computed and manipulate them to rescale the magnetometer data to normalize the output across mx, my and mz. It is possible to accomplish this by calculating the scale factor with the ratio of the average max - min through each axis and the numerical mean of all three axes. This means, for instance, if $x_{max} - x_{min}$ ratio is considerable, $\widetilde{m}_x$ has its magnetic field scale reduced, or if the $y_{max} – y_{max}$ ratio is smaller compared to the other axes, it has its magnetic field values increased. This is known as orthogonal rescaling, identical to a diagonalized 3 x 3 calibration matrix while enabling further scale bias correction.

\lstset{language=Python}
\begin{lstlisting}[frame=single]  % Start your code-block

    # Soft iron correction
    # get average x axis max chord length in counts
    avg_delta_x = (maxx - minx) / 2
    # get average y axis max chord length in counts
    avg_delta_y = (maxy - miny) / 2
    # get average z axis max chord length in counts
    avg_delta_z = (maxz - minz) / 2

    avg_delta = (avg_delta_x + avg_delta_y + avg_delta_z)
    avg_delta /= 3

    scale_x = avg_delta / avg_delta_x
    scale_y = avg_delta / avg_delta_y
    scale_z = avg_delta / avg_delta_z

    self._scale = (scale_x, scale_y, scale_z)
    return self._scale

\end{lstlisting}

The result of rescaling the MPU9250 magnetometer data is shown at figure \ref{fig:mag_calibration_output}:

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/calibrated_magnetometer2D.pgf}}
        \caption{INS Hardware}
        \label{fig:sub1}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/calibrated_magnetometer3D.pgf}}
        \caption{MPU-9250 Breakout}
        \label{fig:sub2}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
    \label{fig:mag_calibration_output}
\end{figure}

\newpage

% \subsection{System Architecture}

% Moreover, the navigation system is equipped with a LoRa antenna enabling the system to transmit at 868MHz/915MHz LoRa bands in real-time at a long distance the position and orientation information to an external gateway (figure \ref{fig:overview}). A visualization of the entire hardware solution is provided at image \ref{fig:full}.

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/overview.pdf}
%     \caption{System overview - Raw measurements from IMU are fused together and numerically integrated to obtain position and orientation. This INS data is transmitted in real-time to a remote node gateway. }
%     \label{fig:overview}
% \end{figure}

\subsection{Experiments}

Several experimental tests were conducted to assess the position performance of the INS under different conditions. Experiments were performed indoors, outdoors, and underwater. These tests typically consisted of carrying the INS in a movable platform, typically a skateboard or an electric scooter forming a geometric shape such as a square or a triangle following a precise path on the floor. Geometric shapes were used to better assess the estimating performance of the system against a ground truth baseline. This section will describe how each set of experiments were carried out and what challenges were faced.

\subsection{Indoor Experiments}

Indoor experiments were executed at Madeira Tecnopolo building, floor –1, in a wide-open interior. A guiding rope was layout out in the floor forming a geometric figure acting as baseline for the experiment. The inertial system was placed on an electrical skateboard powered by a laptop computer, which could have been replaced by a portable battery pack. Three kinds of geometric shapes were tested: line, square, triangle and circle. To better understand how distance affects estimation of position, for every geometric figure, tests were made under two different distance magnitudes: 4 and 8 meters.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/indoor.jpg}
    \caption{ 4 meter side ground square used for baseline of accuracy of inertial system. }
    \label{fig:indoor_square}
\end{figure}

Once the experiment was set up, it was time to start testing the INS. The board was dragged at constant speed through the guideline transporting the inertial system. The INS was continuously estimating orientation and position several times a second and storing data to an SD card. The board was dragged at walking speed and stopped at corners when direction changed.

\begin{figure}
    \centering
    % \begin{subfigure}{1\textwidth}
    %     \centering
    %     \includegraphics[width=1\textwidth]{figures/indoor.jpg}
    %     \caption{ 4 meter side ground square used for baseline of accuracy of inertial system. }
    %     \label{fig:indoor_square}
    % \end{subfigure}

    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/indoor_1.jpg}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/indoor_2.jpg}
    \end{subfigure}
    \caption{Skateboard being dragged along the guideline.}
    \label{fig:indoor_experiment}
\end{figure}

\newpage

\subsection{Outdoor Experiments}

Outdoor experiments were conducted at praça do povo’s square (figure \ref{fig:outdoor_field}), in a sport’s platform with a guiding rope also acting as baseline for the experiment in the forming of geometric figures on the ground. Here, the sports platform consisted of one 28mx28m square, composed of 4m squares forming a 7x7 grid (figure \ref{fig:outdoor_1}). This was helpful since this knowledge could also be used to benchmark the position estimation of the system and easily calculate error margins.

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/outdoor.jpg}
%     \caption{ 5 meter side ground square used for baseline of accuracy of inertial system. }
%     \label{fig:outdoor}
% \end{figure}

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/outdoor_1.jpg}
%     \caption{ Manually pulling the skateboard on each side of the ground square. }
%     \label{fig:outdoor_1}
% \end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.7\textwidth]{figures/outdoor_field.jpg}
    \caption{ Manually pulling the skateboard on each side of the ground square. }
    \label{fig:outdoor_field}
\end{figure}

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.40\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/squares.pdf}
        \caption{  }
        \label{fig:squares}
    \end{subfigure}
    \begin{subfigure}{0.40\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/spiral.pdf}
        \caption{  }
        \label{fig:spiral}
    \end{subfigure}
\end{figure}

% \begin{figure}[!h]
%     \centering
%     \includegraphics[width=0.9\textwidth]{figures/square.pdf}
%     \caption{ Manually pulling the skateboard on each side of the ground square. }
%     \label{fig:square}
% \end{figure}


The inertial system was placed on an electrical scooter in this case, being powered by a laptop computer. Here several shapes were tested, from simple lines, squares and triangles to more complex figures such as the ones illustrated at figure \ref{fig:squares} and figure \ref{fig:spiral}.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/outdoor_1.jpg}
        \caption{ Manually pulling the skateboard on each side of the ground square. }
        \label{fig:outdoor_1}
    \end{subfigure}

    \begin{subfigure}{0.40\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/outdoor_2.jpg}
        \caption{5 meter side ground square used for baseline of accuracy of inertial system.}
        \label{fig:outdoor_2}
    \end{subfigure}
    \begin{subfigure}{0.40\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/outdoor_3.jpg}
        \caption{ Manually pulling the skateboard on each side of the ground square. }
        \label{fig:outdoor_3}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
    \label{fig:hardware}
\end{figure}

\subsection{Underwater Experiments}

Underwater experiments were carried out at Madeira Carlton hotel divepoint, where the INS was placed in an underwater spherical housing built for 360º cameras with a portable battery pack. Since the hardware was inaccessible inside the housing, the software had to be adjusted to support remote triggering of the INS via a wireless hotspot using a mobile phone via an HTTP request signal. Tests of the housing were performed prior to the experiment verifying the presence of any water leaks and the well-functioning of the INS.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth, angle=-90]{figures/underwater.jpg}
        \caption{  }
        \label{fig:underwater}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth, angle=-90]{figures/underwater_1.jpg}
        \caption{  }
        \label{fig:underwater_1}
    \end{subfigure}
\end{figure}

Once safety checks were completed, guaranteeing the feasibility of the study, the team went to Madeira Carlton hotel divepoint, where tests were conducted to evaluate the estimation quality of the proposed solution under water. A 5-meter square net served as guideline for the diver performing the experiment underwater.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.3\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/underwater_2.jpg}
        \caption{  }
        \label{fig:underwater}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/underwater_3.jpg}
        \caption{  }
        \label{fig:underwater_1}
    \end{subfigure}
    \begin{subfigure}{0.3\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/underwater_4.jpg}
        \caption{  }
        \label{fig:underwater_1}
    \end{subfigure}
\end{figure}