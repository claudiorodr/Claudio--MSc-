\section{Experimental Setup}

This section contains the hardware setup used to communicate with the low cost IMU sensors and the platform that the Kalman filter is implemented on. There were two Inertial
Navigation Systems (INS) used to compare the results of the implemented Kalman filter to,
the MIDGII and the UmarimLite. The MIDGII is an expensive INS known as the golden
standard for AHRS and the UmarimLite is a commercially available low-cost AHRS that
uses the open source Paparazzi autopilot software. The experimental setup was chosen such
that the algorithm could be designed and tested without any of the low-cost considerations, this makes it possible to develop the algorithm with no constraints and then optimize the
algorithm for low-cost systems.

\subsection{Hardware}

As our projected solution involved a low-cost navigation system, the hardware selection criteria were primarily founded on availability and cost. The cost reduction normally concedes in accurateness and reliability, although with the recent surge of inexpensive, widely accessible, and precise microelectromechanical systems (MEMS), that is no longer the case. Still, we aim to employ commercially available tools at the lowest possible cost without compromising the design of a robust and accurate inertial navigation system. A LoPy microcontroller was selected as the navigational computing device of the inertial system, meeting the envisioned requirements for low power with flexible and diverse computational capabilities. The LoPy development board interfaces with the external physical inertial sensor through connection pins (figure \ref{fig:hardware}.a) and communicates remotely by LoRa protocol. A PySense expansion board connects with the LoPy module providing a programable interface for the microcontroller. The inertial navigation system encompasses a small MPU-9250 (figure \ref{fig:hardware}.b)

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/INS.jpg}
        \caption{INS Hardware}
        \label{fig:sub1}
    \end{subfigure}%
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/mpu9250.jpg}
        \caption{MPU-9250 Breakout}
        \label{fig:sub2}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
    \label{fig:hardware}
\end{figure}

MPU-9250 inertial measurement unit is one of the most widely available low cost commercial IMUs. It is also considered to have an exceptional quality price ratio. The MPU-9250 contains as well temperature and pressure sensors. This chip is extensively employed in wearable sensors for health, fitness, and sports, motion-based game controllers, and portable gaming. This IMU is operated to estimate motion by identifying the presence of acceleration vectors, rotational rates, and local magnetic field direction. It features an embedded 9-axis MEMS sensor from InvenSense. The MPU-9250 is a combined System-in-package (SIP) comprising an MPU-6500 (3-axis accelerometer and 3-axis gyroscope combination) and an AK8963 3-axis magnetometer.

\subsubsection{Accelerometer}

The triple-axis MEMS accelerometer in MPU-9250 includes a wide range of features:

\begin{itemize}
    \item Digital-output triple-axis accelerometer with a programmable full scale range  of $\pm 2g$, $\pm 4$, $\pm 8g$ and $\pm 16g$ and integrated 16-bit ADCs
    \item Accelerometer normal operating current: $450 \mu A$
    \item The text in the entries may be of any length
    \item Low power accelerometer mode current: $8.4 \mu A$ at $0.98Hz$, $19.8 \mu A$ at 31.$25Hz$
    \item Sleep mode current: $8 \mu A$
    \item User-programmable interrupts
    \item Wake-on-motion interrupt for low power operation of applications processor
    \item Self-test
\end{itemize}

\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                   & Min. & Typ.      & Max.   & Units             \\
            \hline
            Full-Scale range            &      & $\pm 16$  &        & $g$               \\
            Sensitivity Scale Factor    &      & 2,048     &        & $LSB/g$           \\
            Nonlinearity                &      & $\pm 0.1$ &        & $\%$              \\
            Rate Noise Spectral Density &      & 300       &        & $\mu g/\sqrt{Hz}$ \\
            Operating Current           &      & 3.2       &        & $mA$              \\
            Startup Time                &      & 20        &        & $ms$              \\
            Output Data Rate            & $4$  &           & $4000$ & $Hz$              \\
            \hline
        \end{tabular}
        \caption{Accelerometer Specifications. }
        \label{tab:accelerometer_specification}
    \end{center}
\end{table}

\subsubsection{Gyroscope}

The triple-axis MEMS gyroscope in the MPU-9250 includes a wide range of features:

\begin{itemize}
    \item Digital-output X-Axis, Y-Axis, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable fullscale range of $\pm 250$, $\pm 500$, $\pm 1000$, and $\pm 2000^{\circ}/s$ and integrated 16-bit ADCs
    \item Digitally-programmable low-pass filter
    \item Gyroscope operating current: $3.2mA$
    \item Sleep mode current: $8 \mu A$
    \item Factory calibrated sensitivity scale factor
    \item Self-test
\end{itemize}


\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                   & Min. & Typ.       & Max.   & Units                  \\
            \hline
            Full-Scale range            &      & $\pm 2000$ &        & $^{\circ}/s$           \\
            Sensitivity Scale Factor    &      & 131        &        & $LSB/(^{\circ}/s)$     \\
            Nonlinearity                &      & $\pm 0.5$  &        & $\%$                   \\
            Rate Noise Spectral Density &      & 300        &        & $^{\circ}/s/\sqrt{Hz}$ \\
            Operating Current           &      & 450        &        & $\mu A$                \\
            Startup Time                &      & 35         &        & $ms$                   \\
            Output Data Rate            & $4$  &            & $8000$ & $Hz$                   \\
            \hline
        \end{tabular}
        \caption{Gyroscope Specifications. }
        \label{tab:gyroscope_specification}
    \end{center}
\end{table}

\subsubsection{Magnetometer}

The triple-axis MEMS accelerometer in MPU-9250 includes a wide range of features:
\begin{itemize}
    \item 3-axis silicon monolithic Hall-effect magnetic sensor with magnetic concentrator
    \item Wide dynamic measurement range and high resolution with lower current consumption.
    \item Output data resolution of 14 bit ($0.6 \mu T/LSB$) or 16 bit ($15 \mu T/LSB$)
    \item Full scale measurement range is $\pm 4800 \mu T$
    \item Magnetometer normal operating current: $280\mu A$ at $8 Hz$ repetition rate
    \item Self-test function with internal magnetic source to confirm magnetic sensor operation on end products
\end{itemize}

\begin{table}[H]
    \begin{center}
        \begin{tabular}[t]{lcccc}
            \hline
            Parameter                     & Min. & Typ.       & Max. & Units        \\
            \hline
            Full-Scale range              &      & $\pm 4800$ &      & $\mu T$      \\
            Sensitivity Scale Factor      &      & 0.6        &      & $\mu T/ LSB$ \\
            Operating Current             &      & 280        &      & $\mu A$      \\
            Initial Calibration Tolerance &      & $\pm 500$  &      & $LSB$        \\
            \hline
        \end{tabular}
        \caption{Magnetometer specification. }
        \label{tab:magnetometer_multiplication}
    \end{center}
\end{table}

\subsection{Software}
The microcontroller operates MicroPython, a barebones and efficient implementation of Python 3, which incorporates a small subset of the Python standard library. It is optimized to run on microcontrollers and in constrained environments. The inertial module's raw measurements are interpreted by the microcontroller through Inter-Integrated Circuit (I2C) MicroPython driver serial allowing to read the peripherals memory addresses synchronously. The readings of each sensor are later averaged and linearized to better detect and reduce the presence of outlier readings. A fusion algorithm takes as input the averaged data of the accelerometer, gyroscope, and magnetometer. It returns the estimated inertial angles (pitch, roll, and yaw) as well as the projected linear acceleration with a gravity compensation numerical method that utterly removes the effect of the gravity component. Numerically integrating the resultant linear acceleration yields velocity, and double integrating will deliver the body's accumulative position. Merging the AHRS with an accumulative position allows tracking a moving body in three dimensions over time.

\subsection{Calibration}

A correct calibration of such sensors is essential for the compensation of their systematic errors, bias, and scale factor. Each time prior to an experiment, the inertial sensor is calibrated while the system is stationary and stabilized to compensate for static error that might corrupt the measurements.
\subsubsection{Accelerometer Calibration}

\begin{figure}[!h]
    \centering
    \resizebox{1\linewidth}{!}{\input{plots/accelerometer.pgf}}
    \caption{Sensor data on each axis (blue is X-axis, red is Y-axis, green is Z-axis) obtained by the accelerometer, gyroscope, and magnetometer at 100 Hz sampling rate. Accelerometer provided the system's proper acceleration; gyroscope supplied the body's angular rate, and the magnetometer presented the detected magnetic flux.}
    % \label{fig:sensoroutput}
\end{figure}

\subsubsection{Gyroscope Calibration}
\subsubsection{Magnetometer Calibration}
To calibrate the magnetometer, a series of measurements of the nearby magnetic field are taken while holding the sensor in an eight-figure pattern through every orientation possible. Ideally the measurements should portray a perfect sphere centered at the origin and where the radius of the sphere is the magnetic field's strength. Plotting the magnetometer's raw measurements (as seen in figure \ref{plt:raw_magnetometer} and figure \ref{plt:raw_magnetometer3D}), it is visible that these do not form a perfect sphere, nor are they centered at the origin. These are referred to as hard iron and soft iron errors or biases, respectively. If no magnetic anomaly algorithm is applied to perceive and avoid it, such distortions in the magnetic field can be interpreted as changes in orientation.

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/magnetometer2D.pgf}}
        \caption{INS Hardware}
        \label{plt:raw_magnetometer}
    \end{subfigure}

    \begin{subfigure}{0.7\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/magnetometer3D.pgf}}
        \caption{MPU-9250 Breakout}
        \label{plt:raw_magnetometer3D}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
\end{figure}

Hard iron biases are commonly the largest and the simplest errors to rectify. With the magnetic field measurements, it is straightforward to compensate for hard iron biases by keeping track of the minimum and maximum field measured in $\widetilde{m}_x$, $\widetilde{m}_y$ and $\widetilde{m}_z$. Once the minimum and maximum field measured in $\widetilde{m}_x$, $\widetilde{m}_y$ and $\widetilde{m}_z$ are known, the average can be subtracted from the following data which results in the re-centering of the response surface on the origin. The following script illustrates how a hard iron correction could be implemented:

\lstset{language=Python}
\begin{lstlisting}[frame=single]  % Start your code-block

    # Hard iron correction

    # get average x mag bias in counts
    offset_x = (maxx + minx) / 2
    # get average y mag bias in counts
    offset_y = (maxy + miny) / 2
    # get average z mag bias in counts
    offset_z = (maxz + minz) / 2

    self._offset = (offset_x, offset_y, offset_z)
    return self._offset
\end{lstlisting}

It is possible now to filter any soft iron biases by taking the minimum and maximum field measured already computed and manipulate them to rescale the magnetometer data to normalize the output across mx, my and mz. It is possible to accomplish this by calculating the scale factor with the ratio of the average max - min through each axis and the numerical mean of all three axes. This means, for instance, if $x_{max} - x_{min}$ ratio is considerable, $\widetilde{m}_x$ has its magnetic field scale reduced, or if the $y_{max} – y_{max}$ ratio is smaller compared to the other axes, it has its magnetic field values increased. This is known as orthogonal rescaling, identical to a diagonalized 3 x 3 calibration matrix while enabling further scale bias correction.

\lstset{language=Python}
\begin{lstlisting}[frame=single]  % Start your code-block

    # Soft iron correction
    # get average x axis max chord length in counts
    avg_delta_x = (maxx - minx) / 2
    # get average y axis max chord length in counts
    avg_delta_y = (maxy - miny) / 2
    # get average z axis max chord length in counts
    avg_delta_z = (maxz - minz) / 2

    avg_delta = (avg_delta_x + avg_delta_y + avg_delta_z)
    avg_delta /= 3

    scale_x = avg_delta / avg_delta_x
    scale_y = avg_delta / avg_delta_y
    scale_z = avg_delta / avg_delta_z

    self._scale = (scale_x, scale_y, scale_z)
    return self._scale

\end{lstlisting}

The result of rescaling the MPU9250 magnetometer data is shown below:

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/calibrated_magnetometer2D.pgf}}
        \caption{INS Hardware}
        \label{fig:sub1}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
        \centering
        \resizebox{1\linewidth}{!}{\input{plots/calibrated_magnetometer3D.pgf}}
        \caption{MPU-9250 Breakout}
        \label{fig:sub2}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
\end{figure}

\subsection{System Architecture}
Moreover, the navigation system is equipped with a LoRa antenna enabling the system to transmit at 868MHz/915MHz LoRa bands in real-time at a long distance the position and orientation information to an external gateway (figure \ref{fig:overview}). A visualization of the entire hardware solution is provided at image \ref{fig:full}.

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/overview.pdf}
    \caption{System overview - Raw measurements from IMU are fused together and numerically integrated to obtain position and orientation. This INS data is transmitted in real-time to a remote node gateway. }
    \label{fig:overview}
\end{figure}

\subsection{Experiments}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/fullINS.jpg}
    \caption{Complete hardware solution - Box containing the full inertial navigation system, at the left the antenna  suitable for use in the 868MHz/915MHz LoRa bands. }
    \label{fig:full}
\end{figure}
\subsection{Indoor Experiments}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/indoor.jpg}
    \caption{ 5 meter side ground square used for baseline of accuracy of inertial system. }
    \label{fig:indoor}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/indoor_1.jpg}
    \caption{ Manually pulling the skateboard on each side of the ground square. }
    \label{fig:indoor_1}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/indoor_2.jpg}
    \caption{ Experiment made with skateboard to assess localization accuracy. }
    \label{fig:indoor_2}
\end{figure}

\subsection{Outdoor Experiments}
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/outdoor.jpg}
    \caption{ 5 meter side ground square used for baseline of accuracy of inertial system. }
    \label{fig:outdoor}
\end{figure}

\begin{figure}[!h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/outdoor_1.jpg}
    \caption{ Manually pulling the skateboard on each side of the ground square. }
    \label{fig:outdoor_1}
\end{figure}

\begin{figure}[!h]
    \centering
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/outdoor_2.jpg}
        \caption{5 meter side ground square used for baseline of accuracy of inertial system.}
        \label{fig:outdoor_2}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth}
        \centering
        \includegraphics[width=1\textwidth]{figures/outdoor_3.jpg}
        \caption{ Manually pulling the skateboard on each side of the ground square. }
        \label{fig:outdoor_3}
    \end{subfigure}
    \caption{Pin connection between the microcontroller (left) and the IMU (right). Modules are linked through SCL, CLK, VDD and GND pins.}
    \label{fig:hardware}
\end{figure}